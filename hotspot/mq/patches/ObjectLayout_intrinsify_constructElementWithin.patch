# HG changeset patch
# Parent d60bdbca671dfe644146d8842b3e2a2697c67f65
ObjectLayout: intrinsify AbstractIntrinsicObjectModel.constructElementWithin() in the interpreter

diff -r d60bdbca671d src/cpu/x86/vm/interpreterGenerator_x86.hpp
--- a/src/cpu/x86/vm/interpreterGenerator_x86.hpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/cpu/x86/vm/interpreterGenerator_x86.hpp	Sun Jan 11 23:57:40 2015 +0100
@@ -34,6 +34,7 @@
 
   address generate_normal_entry(bool synchronized);
   address generate_native_entry(bool synchronized);
+  address generate_AbstractIntrinsicObjectModel_constructElementWithin();
   address generate_abstract_entry(void);
   address generate_math_entry(AbstractInterpreter::MethodKind kind);
   address generate_jump_to_normal_entry(void);
diff -r d60bdbca671d src/cpu/x86/vm/templateInterpreter_x86_64.cpp
--- a/src/cpu/x86/vm/templateInterpreter_x86_64.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/cpu/x86/vm/templateInterpreter_x86_64.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -801,6 +801,276 @@
   return generate_native_entry(false);
 }
 
+// This is a specialized stub for the intrinsification of
+// org.ObjectLayout.AbstractIntrinsicObjectModel.constructElementWithin()
+// It calls JVM_ObjectLayoutConstructWithin to do the work.
+// This interpreter stub is based on the native entry (see generate_native_entry() below)
+// but should be further optimized/specialized in the future.
+address InterpreterGenerator::generate_AbstractIntrinsicObjectModel_constructElementWithin() {
+  // determine code generation flags
+  bool inc_counter  = UseCompiler || CountCompiledCalls;
+
+  // rbx: Method*
+  // r13: sender sp
+
+  address entry_point = __ pc();
+
+  const Address constMethod       (rbx, Method::const_offset());
+  const Address access_flags      (rbx, Method::access_flags_offset());
+  const Address size_of_parameters(rcx, ConstMethod::
+                                        size_of_parameters_offset());
+
+
+  // get parameter size (always needed)
+  __ movptr(rcx, constMethod);
+  __ load_unsigned_short(rcx, size_of_parameters);
+
+  // native calls don't need the stack size check since they have no
+  // expression stack and the arguments are already on the stack and
+  // we only add a handful of words to the stack
+
+  // rbx: Method*
+  // rcx: size of parameters
+  // r13: sender sp
+  __ pop(rax);                                       // get return address
+
+  // for natives the size of locals is zero
+
+  // compute beginning of parameters (r14)
+  __ lea(r14, Address(rsp, rcx, Address::times_8, -wordSize));
+
+  // add 2 zero-initialized slots for native calls
+  // initialize result_handler slot
+  __ push((int) NULL_WORD);
+  // slot for oop temp
+  // (static native method holder mirror/jni oop result)
+  __ push((int) NULL_WORD);
+
+  // initialize fixed part of activation frame
+  generate_fixed_frame(true);
+
+  bang_stack_shadow_pages(true);
+
+  // start execution
+#ifdef ASSERT
+  {
+    Label L;
+    const Address monitor_block_top(rbp,
+                 frame::interpreter_frame_monitor_block_top_offset * wordSize);
+    __ movptr(rax, monitor_block_top);
+    __ cmpptr(rax, rsp);
+    __ jcc(Assembler::equal, L);
+    __ stop("broken stack frame setup in interpreter");
+    __ bind(L);
+  }
+#endif
+
+  // jvmti support
+  __ notify_method_entry();
+
+  // work registers
+  const Register method = rbx;
+  const Register t      = r11;
+
+  __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
+  __ andptr(rsp, -16); // must be 16 byte boundary (see amd64 ABI)
+
+  // get native function entry point
+  __ lea(rax, ExternalAddress((address)JVM_ObjectLayoutConstructWithin));
+
+  // pass JNIEnv
+  __ lea(c_rarg0, Address(r15_thread, JavaThread::jni_environment_offset()));
+  // we don't need a signature handler because the paramters are known
+  __ lea(c_rarg1, Address(r14, 0));             // 'this' object (AbstractIntrinsicObjectModel)
+  __ lea(c_rarg2, Address(r14, -1 * wordSize)); // enclosing object
+  __ lea(c_rarg3, Address(r14, -2 * wordSize)); // constructor
+  __ lea(c_rarg4, Address(r14, -3 * wordSize)); // args array
+
+  // It is enough that the pc() points into the right code
+  // segment. It does not have to be the correct return pc.
+  __ set_last_Java_frame(rsp, rbp, (address) __ pc());
+
+  // change thread state
+#ifdef ASSERT
+  {
+    Label L;
+    __ movl(t, Address(r15_thread, JavaThread::thread_state_offset()));
+    __ cmpl(t, _thread_in_Java);
+    __ jcc(Assembler::equal, L);
+    __ stop("Wrong thread state in native stub");
+    __ bind(L);
+  }
+#endif
+
+  // Change state to native
+
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()),
+          _thread_in_native);
+
+  // Call the native method.
+  __ call(rax);
+  // result potentially in rax or xmm0
+
+  // Verify or restore cpu control state after JNI call
+  __ restore_cpu_control_state_after_jni();
+
+  // NOTE: The order of these pushes is known to frame::interpreter_frame_result
+  // in order to extract the result of a method call. If the order of these
+  // pushes change or anything else is added to the stack then the code in
+  // interpreter_frame_result must also change.
+
+  __ push(dtos);
+  __ push(ltos);
+
+  // change thread state
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()),
+          _thread_in_native_trans);
+
+  if (os::is_MP()) {
+    if (UseMembar) {
+      // Force this write out before the read below
+      __ membar(Assembler::Membar_mask_bits(
+           Assembler::LoadLoad | Assembler::LoadStore |
+           Assembler::StoreLoad | Assembler::StoreStore));
+    } else {
+      // Write serialization page so VM thread can do a pseudo remote membar.
+      // We use the current thread pointer to calculate a thread specific
+      // offset to write to within the page. This minimizes bus traffic
+      // due to cache line collision.
+      __ serialize_memory(r15_thread, rscratch2);
+    }
+  }
+
+  // check for safepoint operation in progress and/or pending suspend requests
+  {
+    Label Continue;
+    __ cmp32(ExternalAddress(SafepointSynchronize::address_of_state()),
+             SafepointSynchronize::_not_synchronized);
+
+    Label L;
+    __ jcc(Assembler::notEqual, L);
+    __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);
+    __ jcc(Assembler::equal, Continue);
+    __ bind(L);
+
+    // Don't use call_VM as it will see a possible pending exception
+    // and forward it and never return here preventing us from
+    // clearing _last_native_pc down below.  Also can't use
+    // call_VM_leaf either as it will check to see if r13 & r14 are
+    // preserved and correspond to the bcp/locals pointers. So we do a
+    // runtime call by hand.
+    //
+    __ mov(c_rarg0, r15_thread);
+    __ mov(r12, rsp); // remember sp (can only use r12 if not using call_VM)
+    __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
+    __ andptr(rsp, -16); // align stack as required by ABI
+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
+    __ mov(rsp, r12); // restore sp
+    __ reinit_heapbase();
+    __ bind(Continue);
+  }
+
+  // change thread state
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);
+
+  // reset_last_Java_frame
+  __ reset_last_Java_frame(true, true);
+
+  // reset handle block
+  __ movptr(t, Address(r15_thread, JavaThread::active_handles_offset()));
+  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);
+
+  // The result is an oop so unbox and store it in frame where gc will see it
+  // and result handler will pick it up
+  {
+    Label store_result;
+
+    // retrieve result
+    __ pop(ltos);
+    __ testptr(rax, rax);
+    __ jcc(Assembler::zero, store_result);
+    __ movptr(rax, Address(rax, 0));
+    __ bind(store_result);
+    __ movptr(Address(rbp, frame::interpreter_frame_oop_temp_offset*wordSize), rax);
+    // keep stack depth as expected by pushing oop which will eventually be discarde
+    __ push(ltos);
+  }
+
+
+  {
+    Label no_reguard;
+    __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()),
+            JavaThread::stack_guard_yellow_disabled);
+    __ jcc(Assembler::notEqual, no_reguard);
+
+    __ pusha(); // XXX only save smashed registers
+    __ mov(r12, rsp); // remember sp (can only use r12 if not using call_VM)
+    __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
+    __ andptr(rsp, -16); // align stack as required by ABI
+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
+    __ mov(rsp, r12); // restore sp
+    __ popa(); // XXX only restore smashed registers
+    __ reinit_heapbase();
+
+    __ bind(no_reguard);
+  }
+
+
+  // The method register is junk from after the thread_in_native transition
+  // until here.  Also can't call_VM until the bcp has been
+  // restored.  Need bcp for throwing exception below so get it now.
+  __ get_method(method);
+
+  // restore r13 to have legal interpreter frame, i.e., bci == 0 <=>
+  // r13 == code_base()
+  __ movptr(r13, Address(method, Method::const_offset()));   // get ConstMethod*
+  __ lea(r13, Address(r13, ConstMethod::codes_offset()));    // get codebase
+  // handle exceptions (exception handling will handle unlocking!)
+  {
+    Label L;
+    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
+    __ jcc(Assembler::zero, L);
+    // Note: At some point we may want to unify this with the code
+    // used in call_VM_base(); i.e., we should use the
+    // StubRoutines::forward_exception code. For now this doesn't work
+    // here because the rsp is not correctly set at this point.
+    __ MacroAssembler::call_VM(noreg,
+                               CAST_FROM_FN_PTR(address,
+                               InterpreterRuntime::throw_pending_exception));
+    __ should_not_reach_here();
+    __ bind(L);
+  }
+
+  // jvmti support
+  // Note: This must happen _after_ handling/throwing any exceptions since
+  //       the exception handler code notifies the runtime of method exits
+  //       too. If this happens before, method entry/exit notifications are
+  //       not properly paired (was bug - gri 11/22/99).
+  __ notify_method_exit(vtos, InterpreterMacroAssembler::NotifyJVMTI);
+
+  // restore potential result in edx:eax, call result handler to
+  // restore potential result in ST0 & handle result
+
+  __ pop(ltos);
+  __ pop(dtos);
+
+  // retrieve result from frame (we know it's an oop so no need to call a result handler)
+  __ movptr(rax, Address(rbp, frame::interpreter_frame_oop_temp_offset*wordSize));
+  // and verify it
+  __ verify_oop(rax);
+
+  // remove activation
+  __ movptr(t, Address(rbp,
+                       frame::interpreter_frame_sender_sp_offset *
+                       wordSize)); // get sender sp
+  __ leave();                                // remove frame anchor
+  __ pop(rdi);                               // get return address
+  __ mov(rsp, t);                            // set sp to sender sp
+  __ jmp(rdi);
+
+  return entry_point;
+}
+
 // Interpreter stub for calling a native method. (asm interpreter)
 // This sets up a somewhat different looking stack for calling the
 // native method than the typical interpreter frame setup.
diff -r d60bdbca671d src/share/vm/classfile/vmSymbols.hpp
--- a/src/share/vm/classfile/vmSymbols.hpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/classfile/vmSymbols.hpp	Sun Jan 11 23:57:40 2015 +0100
@@ -845,6 +845,13 @@
    do_name(     updateByteBuffer_name,                           "updateByteBuffer")                                    \
    do_signature(updateByteBuffer_signature,                      "(IJII)I")                                             \
                                                                                                                         \
+  /* support for org.ObjectLayout.AbstractIntrinsicObjectModel */                                                       \
+  do_class(org_ObjectLayout_AbstractIntrinsicObjectModel,        "org/ObjectLayout/AbstractIntrinsicObjectModel")       \
+                                                                                                                        \
+  do_intrinsic(_constructElementWithin, org_ObjectLayout_AbstractIntrinsicObjectModel, constructElementWithin_name, constructElementWithin_signature, F_R)   \
+   do_name(     constructElementWithin_name,                     "constructElementWithin")                                                                   \
+   do_signature(constructElementWithin_signature,                "(Ljava/lang/Object;Ljava/lang/reflect/Constructor;[Ljava/lang/Object;)Ljava/lang/Object;") \
+                                                                                                                        \
   /* support for sun.misc.Unsafe */                                                                                     \
   do_class(sun_misc_Unsafe,               "sun/misc/Unsafe")                                                            \
                                                                                                                         \
diff -r d60bdbca671d src/share/vm/gc_interface/collectedHeap.hpp
--- a/src/share/vm/gc_interface/collectedHeap.hpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/gc_interface/collectedHeap.hpp	Sun Jan 11 23:57:40 2015 +0100
@@ -84,6 +84,7 @@
 class CollectedHeap : public CHeapObj<mtInternal> {
   friend class VMStructs;
   friend class IsGCActiveMark; // Block structured external access to _is_gc_active
+  friend class Reflection; // Reflection::construct_within() uses post_allocation_setup_common()
 
  private:
 #ifdef ASSERT
diff -r d60bdbca671d src/share/vm/interpreter/abstractInterpreter.hpp
--- a/src/share/vm/interpreter/abstractInterpreter.hpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/interpreter/abstractInterpreter.hpp	Sun Jan 11 23:57:40 2015 +0100
@@ -90,6 +90,7 @@
     java_util_zip_CRC32_update,                                 // implementation of java.util.zip.CRC32.update()
     java_util_zip_CRC32_updateBytes,                            // implementation of java.util.zip.CRC32.updateBytes()
     java_util_zip_CRC32_updateByteBuffer,                       // implementation of java.util.zip.CRC32.updateByteBuffer()
+    org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin, // ObjectLayout
     number_of_method_entries,
     invalid = -1
   };
diff -r d60bdbca671d src/share/vm/interpreter/interpreter.cpp
--- a/src/share/vm/interpreter/interpreter.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/interpreter/interpreter.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -277,6 +277,10 @@
 
     case vmIntrinsics::_Reference_get:
                                 return java_lang_ref_reference_get;
+
+    case vmIntrinsics::_constructElementWithin:
+                                if (OptimizeObjectLayout)
+                                  return org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin;
   }
 
   // Accessor method?
@@ -339,6 +343,8 @@
     case java_util_zip_CRC32_update           : tty->print("java_util_zip_CRC32_update"); break;
     case java_util_zip_CRC32_updateBytes      : tty->print("java_util_zip_CRC32_updateBytes"); break;
     case java_util_zip_CRC32_updateByteBuffer : tty->print("java_util_zip_CRC32_updateByteBuffer"); break;
+    case org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin
+                                              : tty->print("org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin"); break;
     default:
       if (kind >= method_handle_invoke_FIRST &&
           kind <= method_handle_invoke_LAST) {
@@ -550,6 +556,8 @@
   case Interpreter::java_lang_math_exp     : entry_point = generate_math_entry(kind);      break;
   case Interpreter::java_lang_ref_reference_get
                                            : entry_point = generate_Reference_get_entry(); break;
+  case Interpreter::org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin
+                                           : entry_point = generate_AbstractIntrinsicObjectModel_constructElementWithin(); break;
 #ifndef CC_INTERP
   case Interpreter::java_util_zip_CRC32_update
                                            : entry_point = generate_CRC32_update_entry();  break;
diff -r d60bdbca671d src/share/vm/interpreter/templateInterpreter.cpp
--- a/src/share/vm/interpreter/templateInterpreter.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/interpreter/templateInterpreter.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -390,6 +390,10 @@
     method_entry(java_util_zip_CRC32_updateByteBuffer)
   }
 
+  if (OptimizeObjectLayout) {
+    method_entry(org_ObjectLayout_AbstractIntrinsicObjectModel_constructElementWithin)
+  }
+
   initialize_method_handle_entries();
 
   // all native method kinds (must be one contiguous block)
diff -r d60bdbca671d src/share/vm/oops/method.cpp
--- a/src/share/vm/oops/method.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/oops/method.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -1295,6 +1295,15 @@
   // exception: the AES intrinsics come from lib/ext/sunjce_provider.jar
   // which does not use the class default class loader so we check for its loader here
   InstanceKlass* ik = InstanceKlass::cast(holder);
+  // Hack for ObjectLayout until the ObjectLayout library is in the boot class path
+  if (OptimizeObjectLayout) {
+    Symbol* klass_name = ik->name();
+    if (ik->class_loader() == NULL ||
+        SystemDictionary::is_ext_class_loader(ik->class_loader()) ||
+        klass_name->equals("org/ObjectLayout/AbstractIntrinsicObjectModel")) {
+      return vmSymbols::find_sid(klass_name);
+    }
+  }
   if ((ik->class_loader() != NULL) && !SystemDictionary::is_ext_class_loader(ik->class_loader())) {
     return vmSymbols::NO_SID;   // regardless of name, no intrinsics here
   }
diff -r d60bdbca671d src/share/vm/prims/jvm.cpp
--- a/src/share/vm/prims/jvm.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/prims/jvm.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -3513,6 +3513,43 @@
   return res;
 JVM_END
 
+
+JVM_ENTRY(jobject, JVM_ObjectLayoutConstructWithin(JNIEnv *env, jobject obj, jobject enclosing, jobject cstr, jobjectArray args0))
+  JVMWrapper("JVM_ObjectLayoutConstructWithin");
+
+  static int foff = 0; // this is the offset of org.objectlayout.AbstractIntrinsicObjectModel.field
+  if (foff == 0) {
+    Klass* k = JNIHandles::resolve_non_null(obj)->klass(); // obj is an AbstractIntrinsicObjectModel
+    Symbol* name = SymbolTable::probe("field", 5);
+    Symbol* sig = SymbolTable::probe("Ljava/lang/reflect/Field;", 25);
+    fieldDescriptor fd;
+    k->find_field(name, sig, &fd);
+    foff = fd.offset();
+  }
+
+  oop field = JNIHandles::resolve_non_null(obj)->obj_field(foff);
+
+  // from find_field_offset() in unsafe.cpp
+  oop mirror    = java_lang_reflect_Field::clazz(field);
+  Klass* k      = java_lang_Class::as_Klass(mirror);
+  int slot      = java_lang_reflect_Field::slot(field);
+  int modifiers = java_lang_reflect_Field::modifiers(field);
+  int offset    = InstanceKlass::cast(k)->field_offset(slot);
+
+  oop enclosing_obj = JNIHandles::resolve(enclosing);
+  oop constructor_mirror = JNIHandles::resolve(cstr);
+  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
+
+  oop result = Reflection::construct_within(enclosing_obj, offset, constructor_mirror, args, CHECK_NULL);
+
+  jobject res = JNIHandles::make_local(env, result);
+
+  if (JvmtiExport::should_post_vm_object_alloc()) {
+    JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
+  }
+  return res;
+JVM_END
+
 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
 
 JVM_LEAF(jboolean, JVM_SupportsCX8())
diff -r d60bdbca671d src/share/vm/prims/jvm.h
--- a/src/share/vm/prims/jvm.h	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/prims/jvm.h	Sun Jan 11 23:57:40 2015 +0100
@@ -1204,6 +1204,12 @@
 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 
 /*
+ * org.ObjectLayout.AbstractIntrinsicObjectModel
+ */
+JNIEXPORT jobject JNICALL
+JVM_ObjectLayoutConstructWithin(JNIEnv *env, jobject obj, jobject enclosing, jobject cstr, jobjectArray args0);
+
+/*
  * java.lang.management support
  */
 JNIEXPORT void* JNICALL
diff -r d60bdbca671d src/share/vm/runtime/reflection.cpp
--- a/src/share/vm/runtime/reflection.cpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/runtime/reflection.cpp	Sun Jan 11 23:57:40 2015 +0100
@@ -28,6 +28,7 @@
 #include "classfile/systemDictionary.hpp"
 #include "classfile/verifier.hpp"
 #include "classfile/vmSymbols.hpp"
+#include "gc_interface/collectedHeap.inline.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
@@ -1087,3 +1088,30 @@
   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
   return receiver();
 }
+
+oop Reflection::construct_within(oop enclosing_obj, jlong offset, oop constructor_mirror, objArrayHandle args, TRAPS) {
+  oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
+  int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
+  bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
+  objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
+
+  instanceKlassHandle klass(THREAD, java_lang_Class::as_Klass(mirror));
+  Method* m = klass->method_with_idnum(slot);
+  if (m == NULL) {
+    THROW_MSG_0(vmSymbols::java_lang_InternalError(), "invoke");
+  }
+  methodHandle method(THREAD, m);
+  assert(method->name() == vmSymbols::object_initializer_name(), "invalid constructor");
+
+  // Make sure klass gets initialize
+  klass->initialize(CHECK_NULL);
+
+  char* o = (char*)enclosing_obj + offset; // plain pointer to the embedded receiver
+  // Install the mark word and the klass pointer into the embedded object
+  CollectedHeap::post_allocation_setup_common(klass, (HeapWord*)o);
+  Handle receiver(THREAD, (oop)o);
+
+  // Ignore result from call and return receiver
+  invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
+  return receiver();
+}
diff -r d60bdbca671d src/share/vm/runtime/reflection.hpp
--- a/src/share/vm/runtime/reflection.hpp	Fri Jan 02 10:48:57 2015 +0100
+++ b/src/share/vm/runtime/reflection.hpp	Sun Jan 11 23:57:40 2015 +0100
@@ -139,6 +139,8 @@
   static oop      invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS);
   // Method invocation through java.lang.reflect.Constructor
   static oop      invoke_constructor(oop method_mirror, objArrayHandle args, TRAPS);
+  // Method invocation through org.ObjectLayout.AbstractIntrinsicObjectModel
+  static oop      construct_within(oop enclosing_obj, jlong offset, oop method_mirror, objArrayHandle args, TRAPS);
 
 };
 
